-- Machines
local MinimizeGui = Instance.new("ScreenGui")
MinimizeGui.Name = "MinimizeGui"
MinimizeGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
MinimizeGui.ResetOnSpawn = false

-- Create the minimize button with centered positioning
local MinimizeButton = Instance.new("TextButton")
MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Parent = MinimizeGui
MinimizeButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
MinimizeButton.BorderColor3 = Color3.fromRGB(50, 50, 50)
MinimizeButton.AnchorPoint = Vector2.new(0.5, 0.5)
MinimizeButton.Position = UDim2.new(0.5, 0, 0.5, 0)
MinimizeButton.Size = UDim2.new(0, 80, 0, 40)
MinimizeButton.Font = Enum.Font.GothamBold
MinimizeButton.Text = "Close"
MinimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
MinimizeButton.TextSize = 16.000

-- Add corner radius
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 6)
UICorner.Parent = MinimizeButton

-- Create X button for removal
local CloseButton = Instance.new("TextButton")
CloseButton.Name = "CloseButton"
CloseButton.Parent = MinimizeButton
CloseButton.BackgroundTransparency = 1
CloseButton.Position = UDim2.new(1, -20, 0, 0)
CloseButton.Size = UDim2.new(0, 20, 0, 20)
CloseButton.Font = Enum.Font.GothamBold
CloseButton.Text = "Ã—"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 16.000
CloseButton.ZIndex = 2

-- Close button functionality
CloseButton.MouseButton1Click:Connect(function()
    -- Destroy the MinimizeButton and CloseButton
    MinimizeButton:Destroy()
    CloseButton:Destroy()
    -- Optionally, destroy the entire GUI if needed
    MinimizeGui:Destroy()
end)



-- Make button draggable
local UserInputService = game:GetService("UserInputService")
local dragging
local dragStart
local startPos

MinimizeButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = MinimizeButton.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement and dragging then
        local delta = input.Position - dragStart
        MinimizeButton.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

-- Add hover effects for main button
MinimizeButton.MouseEnter:Connect(function()
    game:GetService("TweenService"):Create(MinimizeButton, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    }):Play()
end)

MinimizeButton.MouseLeave:Connect(function()
    game:GetService("TweenService"):Create(MinimizeButton, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    }):Play()
end)

-- Add hover effects for close button
CloseButton.MouseEnter:Connect(function()
    game:GetService("TweenService"):Create(CloseButton, TweenInfo.new(0.2), {
        TextColor3 = Color3.fromRGB(255, 100, 100)
    }):Play()
end)

CloseButton.MouseLeave:Connect(function()
    game:GetService("TweenService"):Create(CloseButton, TweenInfo.new(0.2), {
        TextColor3 = Color3.fromRGB(255, 255, 255)
    }):Play()
end)

-- Add shadow
local Shadow = Instance.new("ImageLabel")
Shadow.Name = "Shadow"
Shadow.AnchorPoint = Vector2.new(0.5, 0.5)
Shadow.BackgroundTransparency = 1
Shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
Shadow.Size = UDim2.new(1, 10, 1, 10)
Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
Shadow.ImageTransparency = 0.5
Shadow.Image = "rbxassetid://7912134082"
Shadow.Parent = MinimizeButton
Shadow.ZIndex = MinimizeButton.ZIndex - 1

-- Load Fluent UI
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Bean Hub",
    SubTitle = "By Big Bean",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl,
    OnDestroy = function()
        local fadeOut = game:GetService("TweenService"):Create(MinimizeGui, TweenInfo.new(0.5), {
            Transparency = 1
        })
        fadeOut:Play()
        fadeOut.Completed:Connect(function()
            MinimizeGui:Destroy()
        end)
    end
})

local Tabs = {
    Machines = Window:AddTab({ Title = "Machines", Icon = "star" })
}

-- Initialize state
local isMinimized = false
Window:Minimize(false)

-- Regular minimize/maximize functionality
MinimizeButton.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    Window:Minimize(isMinimized)

    local textTween = game:GetService("TweenService"):Create(MinimizeButton, TweenInfo.new(0.2), {
        TextTransparency = 1
    })
    
    textTween:Play()
    textTween.Completed:Connect(function()
        MinimizeButton.Text = isMinimized and "Close" or "Open"
        game:GetService("TweenService"):Create(MinimizeButton, TweenInfo.new(0.2), {
            TextTransparency = 0
        }):Play()
    end)
end)



local Services = {
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    PetServiceRF = game:GetService("ReplicatedStorage").Packages.Knit.Services.PetService.RF:FindFirstChild("getOwned"),
    PetService = game:GetService("ReplicatedStorage").Packages.Knit.Services.PetService.RF,
    PetDeslimeService = {
        Purchase = game:GetService("ReplicatedStorage").Packages.Knit.Services.PetDeslimeService.RE.onPurchase,
        Claim = game:GetService("ReplicatedStorage").Packages.Knit.Services.PetDeslimeService.RE.onClaim
    }
}

local Variables = {
    ownedPetData = {},
    uniquePetNames = {},
    selectedPetName = nil,
    selectedSlimeColors = {},
    autoSlimeEnabled = false,
    hasReportedCompletion = false
}

local GoliathPetsSection = Tabs.Machines:AddSection("Goliath")

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-- Configuration
local CONFIG = {
    SLOT_WAIT_TIME = 910,  -- Wait time per slot
    DROPDOWN_REFRESH_INTERVAL = 5,  -- Dropdown refresh interval
    PET_REFRESH_INTERVAL = 30,  -- Interval to refresh huge/unlocked pets
}
-- Services and Remote Function
local PetServiceRF = ReplicatedStorage.Packages.Knit.Services.PetService.RF:FindFirstChild("getOwned")
local PetGoliathService = ReplicatedStorage.Packages.Knit.Services.PetGoliathService.RE

-- Pet Data Management
local ownedPetData = {} -- Maps pet names to their IDs
local petNames = {}
local selectedPetName = nil  -- Track selected pet globally
local isAutoGoliathRunning = false  -- Flag to control the automation loop

-- Fetch Pet Data
local function fetchPetData()
    -- Reset existing data
    ownedPetData = {}
    petNames = {}

    if not PetServiceRF or not PetServiceRF:IsA("RemoteFunction") then
        warn("RemoteFunction 'getOwned' is invalid or unavailable.")
        return false
    end

    local success, petData = pcall(function()
        return PetServiceRF:InvokeServer()
    end)

    if not success or not petData then
        warn("Failed to fetch pets or no pets found.")
        return false
    end

    for petId, petInfo in pairs(petData) do
        -- Process only Huge and unlocked pets
        if petInfo.CraftType == "Huge" and petInfo.Locked == false then
            local displayName = petInfo.Key
            if not ownedPetData[displayName] then
                ownedPetData[displayName] = {}
            end
            table.insert(ownedPetData[displayName], petId)

            if not table.find(petNames, displayName) then
                table.insert(petNames, displayName)
            end
        end
    end

    return true
end

-- Pet Dropdown
local PetDropdown = Tabs.Machines:AddDropdown("SelectPet", {
    Title = "Select Your Pet",
    Description = "Choose the name of the pets you want to goliath (The pet will only appear if its a huge and is unlocked).",
    Values = petNames,
    Multi = false,
})

Tabs.Machines:AddButton({
    Title = "Refresh Goliath Pets",
    Description = "Manually refresh the pet dropdown list",
    Callback = function()
        if fetchPetData() then
            PetDropdown:SetValues(petNames)
            print("Goliath pets refreshed successfully!")
        else
            warn("Failed to refresh Goliath pets")
        end
    end
})

-- Periodically Update Huge/Unlocked Pet IDs
local function periodicPetDataRefresh()
    spawn(function()
        while true do
            fetchPetData()
            wait(CONFIG.PET_REFRESH_INTERVAL)
        end
    end)
end

-- Dropdown Selection Handler
PetDropdown:OnChanged(function(selectedPet)
    selectedPetName = selectedPet  -- Store selected pet globally
    local ids = ownedPetData[selectedPet] or {}
    
    if #ids > 0 then
        for _, id in ipairs(ids) do
        end
    else
    end
end)

-- Add paragraph for user instructions
Tabs.Machines:AddParagraph({
    Title = "Pet Info",
    Content = [[When selecting a pet, check the console to verify if the pet IDs are displayed correctly.  
If the IDs aren't showing, select a different pet and then switch back to refresh the IDs.

Note: This Goliath automation only works for unlocked pets.  
If you want specific huge pets to stay huge, make sure to lock them.]]
})

-- Auto Goliath Toggle
local AutoGoliathToggle = Tabs.Machines:AddToggle("Auto Goliath", {
    Title = "Enable Auto Goliath",
    Description = "Star Auto Goliathing your pets.",
    State = false
})

-- Auto Goliath Function
local function AutoGoliath(selectedIDs)
    if not selectedIDs or #selectedIDs == 0 then
        warn("No pets selected for Goliath.")
        return
    end

    local currentIndex = 1

    while isAutoGoliathRunning do
        local slotsToFill = math.min(3, #selectedIDs)

        for i = 1, slotsToFill do
            local petId = selectedIDs[((currentIndex + i - 2) % #selectedIDs) + 1]
            
            local purchaseArgs = {
                [1] = petId,
                [2] = "Slot" .. i
            }

            PetGoliathService.onPurchase:FireServer(unpack(purchaseArgs))
        end

        task.wait(CONFIG.SLOT_WAIT_TIME)

        for i = 1, slotsToFill do
            local claimArgs = {
                [1] = "PlaceholderString",
                [2] = "Slot" .. i,
            }

            PetGoliathService.onClaim:FireServer(unpack(claimArgs))
        end

        currentIndex = ((currentIndex + slotsToFill - 1) % #selectedIDs) + 1
    end
end

-- Auto Goliath Toggle Handler
AutoGoliathToggle:OnChanged(function(enabled)
    if enabled then
        
        if not selectedPetName then
            warn("Please select a pet to use for Goliath.")
            AutoGoliathToggle:Set(false)
            return
        end

        local selectedIDs = ownedPetData[selectedPetName]
        if not selectedIDs or #selectedIDs == 0 then
            warn("No pet IDs found.")
            AutoGoliathToggle:Set(false)
            return
        end

        isAutoGoliathRunning = true
        spawn(function()
            AutoGoliath(selectedIDs)
        end)
    else
        isAutoGoliathRunning = false
    end
end)



local MutatePetsSection = Tabs.Machines:AddSection("Mutate")

-- Services and Variables
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local PetServiceRF = ReplicatedStorage.Packages.Knit.Services.PetService.RF:FindFirstChild("getOwned")
local PetCombineService = ReplicatedStorage.Packages.Knit.Services.PetCombineService.RF
local PetCureFn = PetCombineService:FindFirstChild("cure")
local PetMutateFn = PetCombineService:FindFirstChild("mutate")

local mutationData = {
    selectedPet = nil,
    targetMutation = nil,
    running = false,
    keepGhost = false,
    keepCosmic = false
}

local ownedPetData = {}
local uniquePetNames = {}
local stopLoop = false
local hasReportedCompletion = false

-- Helper function to extract mutation from pet data structure
local function getMutation(tbl)
    if not tbl then return nil end
    for key, value in pairs(tbl) do
        if type(value) == "string" then
            if value:match("Rainbow") then return "Rainbow"
            elseif value:match("Glowing") then return "Glowing"
            elseif value:match("Ghost") then return "Ghost"
            elseif value:match("Cosmic") then return "Cosmic"
            end
        elseif type(value) == "table" then
            local result = getMutation(value)
            if result then return result end
        end
    end
    return nil
end

-- Batch execution function for operations
local function executeBatch(operations, delay)
    delay = delay or 0.1
    for _, operation in ipairs(operations) do
        pcall(operation)
        if delay > 0 then
            wait(delay)
        end
    end
end

-- Enhanced pet data fetcher for mutations
local function fetchOwnedPets()
    ownedPetData = {}
    uniquePetNames = {}

    if PetServiceRF and PetServiceRF:IsA("RemoteFunction") then
        local success, petData = pcall(function()
            return PetServiceRF:InvokeServer()
        end)

        if success and type(petData) == "table" then
            for petId, petInfo in pairs(petData) do
                local displayName = petInfo.Key or "Unknown"

                if not ownedPetData[displayName] then
                    ownedPetData[displayName] = {}
                end

                table.insert(ownedPetData[displayName], {
                    Id = petId,
                    Locked = petInfo.Locked,
                    Mutation = getMutation(petInfo) or "No Mutation"
                })
            end

            for petName, petInstances in pairs(ownedPetData) do
                for _, petInfo in ipairs(petInstances) do
                    if not petInfo.Locked then
                        if not table.find(uniquePetNames, petName) then
                            table.insert(uniquePetNames, petName)
                        end
                        break
                    end
                end
            end
            return true
        else
            warn("Failed to fetch pet data or received invalid data.")
        end
    else
        warn("PetServiceRF is not a valid RemoteFunction.")
    end
    return false
end

local PetDropdown = Tabs.Machines:AddDropdown("PetDropdown", {
    Title = "Select Pet",
    Description = "Choose a specific unlocked pet name to mutate.",
    Values = uniquePetNames,
    Multi = false,
})

local function refreshDropdown()
    if fetchOwnedPets() then
        PetDropdown:SetValues(uniquePetNames)

        if mutationData.selectedPet and not table.find(uniquePetNames, mutationData.selectedPet) then
            mutationData.selectedPet = nil
            PetDropdown:SetValue(nil)
        end
    end
end


Tabs.Machines:AddButton({
    Title = "Refresh/Get Mutate Pets",
    Description = "Manually refresh and get pets for the mutation dropdown",
    Callback = function()
        if fetchOwnedPets() then
            PetDropdown:SetValues(uniquePetNames)
            print("Mutation pets refreshed successfully!")
        else
            warn("Failed to refresh mutation pets")
        end
    end
})

PetDropdown:OnChanged(function(value)
    mutationData.selectedPet = value
    hasReportedCompletion = false

    if mutationData.selectedPet then
        local petInstances = ownedPetData[mutationData.selectedPet] or {}
        for _, petInfo in ipairs(petInstances) do
            if not petInfo.Locked then
            end
        end
    end
end)

local MutationDropdown = Tabs.Machines:AddDropdown("MutationDropdown", {
    Title = "Select Mutation",
    Description = "Choose a mutation to aim for.",
    Values = { "Glowing", "Rainbow", "Ghost", "Cosmic" },
    Multi = false,
})

MutationDropdown:OnChanged(function(value)
    mutationData.targetMutation = value
    hasReportedCompletion = false
end)

local KeepGhostToggle = Tabs.Machines:AddToggle("KeepGhostToggle", {
    Title = "Keep Ghost Pets",
    Description = "Keep pets if they become Ghost mutation, even if Ghost isn't selected.",
    Default = false,
})

KeepGhostToggle:OnChanged(function(value)
    mutationData.keepGhost = value
end)

local KeepCosmicToggle = Tabs.Machines:AddToggle("KeepCosmicToggle", {
    Title = "Keep Cosmic Pets",
    Description = "Keep pets if they become Cosmic mutation, even if Cosmic isn't selected.",
    Default = false,
})

KeepCosmicToggle:OnChanged(function(value)
    mutationData.keepCosmic = value
end)

local function shouldProcessPet(pet)
    if mutationData.keepGhost and pet.Mutation == "Ghost" then
        return false
    end
    if mutationData.keepCosmic and pet.Mutation == "Cosmic" then
        return false
    end
    return pet.Mutation == "No Mutation" or pet.Mutation ~= mutationData.targetMutation
end

local function checkAllPetsMutated()
    if not mutationData.selectedPet or not mutationData.targetMutation then return false end

    local petsToProcess = {}
    for _, petInfo in pairs(ownedPetData[mutationData.selectedPet] or {}) do
        if not petInfo.Locked then
            table.insert(petsToProcess, petInfo)
        end
    end

    for _, pet in pairs(petsToProcess) do
        if pet.Mutation ~= mutationData.targetMutation then
            return false
        end
    end

    return true
end

local function ultraFastMutateLoop()
    stopLoop = false
    hasReportedCompletion = false
    
    while not stopLoop do
        if not (mutationData.selectedPet and mutationData.targetMutation) then
            warn("Please select a pet name and mutation before enabling Ultra Fast Mutate.")
            wait(2)
            continue
        end

        if not ownedPetData[mutationData.selectedPet] then
            warn("No data available for the selected pet.")
            wait(2)
            continue
        end

        if checkAllPetsMutated() then
            if not hasReportedCompletion then
                hasReportedCompletion = true
            end
            wait(1.5)
            continue
        end

        local petsToProcess = {}
        for _, petInfo in pairs(ownedPetData[mutationData.selectedPet] or {}) do
            if not petInfo.Locked and shouldProcessPet(petInfo) then
                table.insert(petsToProcess, petInfo)
            end
        end

        -- Batch cure operations first
        local cureOperations = {}
        local mutateOperations = {}

        for _, pet in pairs(petsToProcess) do
            if stopLoop then break end

            if pet.Mutation ~= mutationData.targetMutation then
                if pet.Mutation ~= "No Mutation" and
                   not (mutationData.keepGhost and pet.Mutation == "Ghost") and
                   not (mutationData.keepCosmic and pet.Mutation == "Cosmic") then
                    
                    if PetCureFn and pet.Id then
                        table.insert(cureOperations, function()
                            return PetCureFn:InvokeServer(pet.Id)
                        end)
                    else
                        warn("Cure function not found or Pet ID is invalid.")
                    end
                    
                elseif pet.Mutation == "No Mutation" then
                    if PetMutateFn and pet.Id then
                        table.insert(mutateOperations, function()
                            return PetMutateFn:InvokeServer(pet.Id, {})
                        end)
                    else
                        warn("Mutate function not found or Pet ID is invalid.")
                    end
                end
            end
        end

        -- Execute cure operations with minimal delay
        if #cureOperations > 0 then
            executeBatch(cureOperations, 0.1)
            wait(0.5) -- Reduced wait time for cure processing
        end

        -- Execute mutate operations with minimal delay
        if #mutateOperations > 0 then
            executeBatch(mutateOperations, 0.1)
        end

        wait(1) -- Reduced overall wait time
        fetchOwnedPets()
    end
end

local AutoMutateToggle = Tabs.Machines:AddToggle("AutoMutateToggle", {
    Title = "Ultra Fast Mutate",
    Description = "Automatically handles curing and mutation loops with optimized speed.",
    Default = false,
})

AutoMutateToggle:OnChanged(function(value)
    if value then
        mutationData.running = true
        ultraFastMutateLoop()
    else
        mutationData.running = false
        stopLoop = true
    end
end)

Tabs.Machines:AddButton({
    Title = "Randomly Mutate Pets",
    Description = "Randomly mutate selected pet IDs without curing them.",
    Callback = function()
        if not mutationData.selectedPet then
            warn("Please select a pet name before using the mutation button.")
            return
        end

        local petsToMutate = {}
        for _, petInfo in ipairs(ownedPetData[mutationData.selectedPet] or {}) do
            if not petInfo.Locked then
                table.insert(petsToMutate, petInfo.Id)
            end
        end

        if #petsToMutate == 0 then
            warn("No unlocked pets available for mutation.")
            return
        end

        if PetMutateFn then
            for _, petId in ipairs(petsToMutate) do
                local mutateArgs = { [1] = petId, [2] = {} }
                pcall(function()
                    PetMutateFn:InvokeServer(unpack(mutateArgs))
                end)
            end
            fetchOwnedPets()
        else
            warn("Mutate function not found!")
        end
    end,
})



local SlimePetsSection = Tabs.Machines:AddSection("Slime")



local function fetchOwnedPets()
    Variables.ownedPetData = {}
    Variables.uniquePetNames = {}

    if Services.PetServiceRF and Services.PetServiceRF:IsA("RemoteFunction") then
        local success, petData = pcall(function()
            return Services.PetServiceRF:InvokeServer()
        end)

        if success and type(petData) == "table" then
            for petId, petInfo in pairs(petData) do
                if not petInfo.Locked then
                    local displayName = petInfo.Key or "Unknown"

                    if not Variables.ownedPetData[displayName] then
                        Variables.ownedPetData[displayName] = {}
                    end

                    table.insert(Variables.ownedPetData[displayName], {
                        Id = petId,
                        Name = displayName,
                        Slime = petInfo.Slime or "None"
                    })
                end
            end

            for petName in pairs(Variables.ownedPetData) do
                table.insert(Variables.uniquePetNames, petName)
            end

            table.sort(Variables.uniquePetNames)
            return true
        end
    end
    return false
end

local function slimifyPet(petId)
    local args = {[1] = petId}
    return Services.PetService.slimify:InvokeServer(unpack(args))
end

local function deslimePet(petId)
    local args = {[1] = petId}
    Services.PetDeslimeService.Purchase:FireServer(unpack(args))
    wait(63)
    Services.PetDeslimeService.Claim:FireServer()
end

local function checkAllPetsSlimed()
    if not Variables.selectedPetName or #Variables.selectedSlimeColors == 0 then return false end
    
    local petsToProcess = Variables.ownedPetData[Variables.selectedPetName] or {}
    for _, petInfo in ipairs(petsToProcess) do
        if not table.find(Variables.selectedSlimeColors, petInfo.Slime) then
            return false
        end
    end
    return true
end

local function processAutoSlime()
    spawn(function()
        while Variables.autoSlimeEnabled do
            if Variables.selectedPetName and #Variables.selectedSlimeColors > 0 then
                if checkAllPetsSlimed() then
                    if not Variables.hasReportedCompletion then
                        Variables.hasReportedCompletion = true
                    end
                    wait(1)
                    continue
                end

                Variables.hasReportedCompletion = false
                local petInstances = Variables.ownedPetData[Variables.selectedPetName] or {}
                
                for _, petInfo in ipairs(petInstances) do
                    if not Variables.autoSlimeEnabled then break end
                    
                    if petInfo.Slime == "None" then
                        slimifyPet(petInfo.Id)
                        wait(1)
                        fetchOwnedPets()
                    elseif not table.find(Variables.selectedSlimeColors, petInfo.Slime) then
                        deslimePet(petInfo.Id)
                        wait(1)
                        slimifyPet(petInfo.Id)
                        wait(1)
                        fetchOwnedPets()
                    end
                end
            end
            wait(1)
        end
    end)
end


local PetDropdown = Tabs.Machines:AddDropdown("PetDropdown", {
    Title = "Select a pet name to Slime",
    Description = "This will slime all unlocked pets that have this name",
    Values = Variables.uniquePetNames,
    Multi = false,
})

local SlimeDropdown = Tabs.Machines:AddDropdown("SlimeColors", {
    Title = "Select Slime",
    Description = "Choose slimes to keep",
    Values = {"Yellow", "Blue", "Purple", "Red", "Black", "Green"},
    Multi = true,
    Default = {}
})

local AutoSlimeToggle = Tabs.Machines:AddToggle("AutoSlimeToggle", {
    Title = "Auto Slime",
    Description = "Automatically slime pets",
    Default = false
})

local RandomSlimeButton = Tabs.Machines:AddButton({
    Title = "Random Slime All Pets",
    Description = "Slimify all unlocked pets that have no slime",
    Callback = function()
        if Services.PetServiceRF then
            local success, petData = pcall(function()
                return Services.PetServiceRF:InvokeServer()
            end)
            
            if success and petData then
                local unslimed = {}
                
                for petId, petInfo in pairs(petData) do
                    if not petInfo.Locked and (petInfo.Slime == "None" or not petInfo.Slime) then
                        table.insert(unslimed, petId)
                    end
                end
                
                if #unslimed > 0 then
                    for i, petId in ipairs(unslimed) do
                        slimifyPet(petId)
                        wait(1)
                    end
                else
                end
            end
        end
    end
})

PetDropdown:OnChanged(function(value)
    Variables.selectedPetName = value
    if Variables.selectedPetName then
        local petInstances = Variables.ownedPetData[Variables.selectedPetName] or {}

        for _, petInfo in ipairs(petInstances) do
            print(string.format("%-36s | %-20s | %s", 
                tostring(petInfo.Id),
                petInfo.Name,
                tostring(petInfo.Slime)
            ))
        end
        print(string.rep("-", 80))
    end
end)

SlimeDropdown:OnChanged(function(value)
    Variables.selectedSlimeColors = {}
    for color, isSelected in pairs(value) do
        if isSelected then
            table.insert(Variables.selectedSlimeColors, color)
        end
    end
    if #Variables.selectedSlimeColors > 0 then
        print("Selected Slimes:", table.concat(Variables.selectedSlimeColors, ", "))
    end
end)

AutoSlimeToggle:OnChanged(function(value)
    Variables.autoSlimeEnabled = value
    Variables.hasReportedCompletion = false
    if value then
        processAutoSlime()
    end
end)

Tabs.Machines:AddButton({
    Title = "Refresh/Get Slime Pets",
    Description = "Manually refresh/get pets for the slime dropdown",
    Callback = function()
        if fetchOwnedPets() then
            PetDropdown:SetValues(Variables.uniquePetNames)
            print("Slime pets refreshed successfully!")
        else
            warn("Failed to refresh slime pets")
        end
    end
})


local EnchantPetsSection = Tabs.Machines:AddSection("Rift Enchant")
-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local PetServiceRF = ReplicatedStorage.Packages.Knit.Services.PetService.RF:FindFirstChild("getOwned")
local RiftMachineService = ReplicatedStorage.Packages.Knit.Services.RiftMachineService.RF

-- Variables
local ownedPetData = {}
local uniquePetNames = {}
local selectedPetName = nil
local selectedEnchants = {}
local slotPets = {[1] = nil, [2] = nil, [3] = nil}
local completedPets = {}


-- Helper Functions
local function fetchOwnedPets()
    if not PetServiceRF then return false end
    
    local success, petData = pcall(function()
        return PetServiceRF:InvokeServer()
    end)

    if success and petData then
        ownedPetData = {}
        uniquePetNames = {}
        
        for petId, petInfo in pairs(petData) do
            if not petInfo.Locked then
                local displayName = petInfo.Key or "Unknown"
                if not ownedPetData[displayName] then
                    ownedPetData[displayName] = {}
                    table.insert(uniquePetNames, displayName)
                end
                table.insert(ownedPetData[displayName], {
                    Id = petId,
                    Enchantment = petInfo.Enchantment
                })
            end
        end
        table.sort(uniquePetNames)
        return true
    end
    return false
end

-- Check current enchant of a pet
local function getPetEnchant(petId)
    local success, petData = pcall(function()
        return PetServiceRF:InvokeServer()
    end)
    
    if success and petData and petData[petId] and petData[petId].Enchantment then
        return petData[petId].Enchantment.Display
    end
    return nil
end

-- UI Elements
local PetDropdown = Tabs.Machines:AddDropdown("PetDropdown", {
    Title = "Select Pet",
    Description = "Choose a specific unlocked pet name.",
    Values = uniquePetNames,
    Multi = false,
})

local EnchantDropdown = Tabs.Machines:AddDropdown("EnchantDropdown", {
    Title = "Select Enchant(s)",
    Description = "Choose enchant levels to apply.",
    Values = { "I", "II", "III", "IV" },
    Multi = true,
    Default = {},
})

local AutoEnchantToggle = Tabs.Machines:AddToggle("AutoEnchantToggle", {
    Title = "Auto Enchant (Selected)",
    Description = "Automatically enchant pets to selected level",
    Default = false
})

PetDropdown:OnChanged(function(value)
    selectedPetName = value
    completedPets = {}
    if selectedPetName then
        print("\n[SELECTED] Pet:", selectedPetName)
        local petInstances = ownedPetData[selectedPetName] or {}
        for _, petInfo in ipairs(petInstances) do
            local enchant = petInfo.Enchantment and petInfo.Enchantment.Display or "No Enchant"
            print(string.format("[PET] ID: %s | Enchant: %s", petInfo.Id, enchant))
        end
    end
end)

EnchantDropdown:OnChanged(function(value)
    selectedEnchants = {}
    for enchant, isSelected in pairs(value) do
        if isSelected then
            table.insert(selectedEnchants, "Rifted " .. enchant)
        end
    end
    
    if #selectedEnchants > 0 then
        print("\n[TARGET] Enchants:", table.concat(selectedEnchants, ", "))
    else
        print("No enchants selected")
    end
end)


AutoEnchantToggle:OnChanged(function(value)
    if value then
        print("\n[AUTO ENCHANT] Started")
        spawn(function()
            while AutoEnchantToggle.Value do
                if selectedPetName and #selectedEnchants > 0 then
                    local petInstances = ownedPetData[selectedPetName] or {}
                    
                    -- Fill empty slots with unique pets
                    for slot = 1, 3 do
                        if not slotPets[slot] then
                            for _, petInfo in ipairs(petInstances) do
                                if completedPets[petInfo.Id] then continue end
                                
                                local currentEnchant = petInfo.Enchantment and petInfo.Enchantment.Display
                                if table.find(selectedEnchants, currentEnchant) then
                                    print(string.format("[SKIP] Pet ID: %s already has desired enchant: %s", petInfo.Id, currentEnchant))
                                    completedPets[petInfo.Id] = true
                                    continue
                                end
                                
                                if not table.find(slotPets, petInfo.Id) then
                                    print(string.format("\n[SLOT %d] Adding pet ID: %s", slot, petInfo.Id))
                                    print(string.format("[CURRENT] Enchant: %s", currentEnchant or "No Enchant"))
                                    RiftMachineService.AddSlot:InvokeServer(tostring(slot), petInfo.Id)
                                    slotPets[slot] = petInfo.Id
                                    break
                                end
                            end
                        end
                    end
                    
                    if slotPets[1] or slotPets[2] or slotPets[3] then
                        print("\n[WAITING] 910 seconds...")
                        wait(910)
                        
                        for slot = 1, 3 do
                            if slotPets[slot] then
                                local petId = slotPets[slot]
                                print(string.format("\n[CLAIMING] Slot %d | Pet ID: %s", slot, petId))
                                RiftMachineService.Claim:InvokeServer(tostring(slot))
                                
                                -- Fetch updated pet data
                                wait(1)
                                local success, petData = pcall(function()
                                    return PetServiceRF:InvokeServer()
                                end)
                                
                                if success and petData[petId] and petData[petId].Enchantment then
                                    local newEnchant = petData[petId].Enchantment.Display
                                    print(string.format("[RESULT] Pet ID: %s | New Enchant: %s", petId, newEnchant or "No Enchant"))
                                    
                                    if table.find(selectedEnchants, newEnchant) then
                                        print(string.format("[SUCCESS] Pet ID: %s got desired enchant!", petId))
                                        completedPets[petId] = true
                                    else
                                        print(string.format("[CONTINUE] Pet ID: %s will continue enchanting", petId))
                                    end
                                end
                                
                                slotPets[slot] = nil
                            end
                        end
                        
                        fetchOwnedPets()
                        
                        local allDone = true
                        for _, petInfo in ipairs(petInstances) do
                            if not completedPets[petInfo.Id] then
                                allDone = false
                                break
                            end
                        end
                        
                        if allDone then
                            print("\n[COMPLETE] All pets have reached desired enchants!")
                            AutoEnchantToggle:Set(false)
                            break
                        end
                    end
                end
                wait(1)
            end
        end)
    else
        print("\n[AUTO ENCHANT] Stopped")
        slotPets = {[1] = nil, [2] = nil, [3] = nil}
        completedPets = {}
    end
end)

Tabs.Machines:AddButton({
    Title = "Refresh/Get Enchant Pets",
    Description = "Manually refresh/get the enchant pet dropdown",
    Callback = function()
        if fetchOwnedPets() then
            PetDropdown:SetValues(uniquePetNames)
            print("Enchant pets refreshed successfully!")
        else
            warn("Failed to refresh enchant pets")
        end
    end
})

-- Services and Variables Table
local SrvVars = {
    Services = {
        ReplicatedStorage = game:GetService("ReplicatedStorage"),
        PetServiceRF = nil,
        ArmsServiceRF = nil
    },
    Data = {
        ownedPetData = {},
        uniquePetNames = {},
        ownedArmsData = {},
        uniqueArmNames = {},
        selectedPetName = nil,
        selectedGoldChance = "20%",
        selectedArms = nil,
        selectedArmChance = "20%",
        autoGoldPets = false,
        autoGoldArms = false,
        lastUsedPetIds = {},
        lastUsedArmIds = {},
        lastRefreshTime = 0,
        refreshInterval = 5 -- 5 seconds refresh interval
    }
}

-- Initialize Services
SrvVars.Services.PetServiceRF = SrvVars.Services.ReplicatedStorage.Packages.Knit.Services.PetService.RF:FindFirstChild("getOwned")
SrvVars.Services.ArmsServiceRF = SrvVars.Services.ReplicatedStorage.Packages.Knit.Services.ArmsService.RF:FindFirstChild("getOwned")

-- Function to get random IDs while avoiding recently used ones
local function getRandomIds(itemTable, count, lastUsedIds, itemName)
    local ids = {}
    local availableIds = {}
    
    -- Check if it's time to refresh IDs
    local currentTime = tick()
    if currentTime - SrvVars.Data.lastRefreshTime >= SrvVars.Data.refreshInterval then
        table.clear(lastUsedIds)
        SrvVars.Data.lastRefreshTime = currentTime
    end
    
    -- Collect all available IDs that weren't recently used
    for _, itemInfo in ipairs(itemTable) do
        if not itemInfo.Locked and not table.find(lastUsedIds, itemInfo.Id) then
            table.insert(availableIds, itemInfo.Id)
        end
    end
    
    -- If we don't have enough unused IDs, clear the used IDs list and try again
    if #availableIds < count then
        table.clear(lastUsedIds)
        for _, itemInfo in ipairs(itemTable) do
            if not itemInfo.Locked then
                table.insert(availableIds, itemInfo.Id)
            end
        end
    end
    
    -- If we still don't have enough IDs, return empty table
    if #availableIds < count then
        print("Not enough " .. itemName .. " remaining")
        return {}
    end
    
    -- Randomly select the required number of IDs
    while #ids < count and #availableIds > 0 do
        local randomIndex = math.random(1, #availableIds)
        local selectedId = availableIds[randomIndex]
        table.insert(ids, selectedId)
        table.insert(lastUsedIds, selectedId)
        table.remove(availableIds, randomIndex)
    end
    
    return ids
end

-- Function to get required count based on percentage
local function getRequiredCount(percentage)
    local percentNum = tonumber(string.match(percentage, "(%d+)"))
    return math.floor(percentNum / 20)
end

-- Updated fetchOwnedPets function with error handling
local function fetchOwnedPets()
    SrvVars.Data.ownedPetData = {}
    SrvVars.Data.uniquePetNames = {}

    if not SrvVars.Services.PetServiceRF or not SrvVars.Services.PetServiceRF:IsA("RemoteFunction") then
        warn("PetServiceRF is not properly initialized")
        return
    end

    local success, petData = pcall(function()
        return SrvVars.Services.PetServiceRF:InvokeServer()
    end)

    if not success then
        warn("Failed to fetch pet data:", petData)
        return
    end

    if type(petData) ~= "table" then
        warn("Invalid pet data received")
        return
    end

    -- Process pet data
    for petId, petInfo in pairs(petData) do
        if type(petInfo) == "table" then
            local displayName = petInfo.Key or "Unknown"
            
            if petInfo.Tier == "Normal" and not petInfo.Locked then
                if not SrvVars.Data.ownedPetData[displayName] then
                    SrvVars.Data.ownedPetData[displayName] = {}
                end
                
                table.insert(SrvVars.Data.ownedPetData[displayName], {
                    Id = petId,
                    Locked = petInfo.Locked,
                    Mutation = petInfo.Mutation or "No Mutation"
                })
            end
        end
    end

    -- Sort and update unique pet names
    local petNameCounts = {}
    for petName, pets in pairs(SrvVars.Data.ownedPetData) do
        table.insert(petNameCounts, {name = petName, count = #pets})
    end
    
    table.sort(petNameCounts, function(a, b) 
        return a.count > b.count 
    end)
    
    for _, petData in ipairs(petNameCounts) do
        table.insert(SrvVars.Data.uniquePetNames, petData.name)
    end
end

-- Updated fetchOwnedArms function with error handling
local function fetchOwnedArms()
    SrvVars.Data.ownedArmsData = {}
    SrvVars.Data.uniqueArmNames = {}

    if not SrvVars.Services.ArmsServiceRF or not SrvVars.Services.ArmsServiceRF:IsA("RemoteFunction") then
        warn("ArmsServiceRF is not properly initialized")
        return
    end

    local success, armsData = pcall(function()
        return SrvVars.Services.ArmsServiceRF:InvokeServer()
    end)

    if not success then
        warn("Failed to fetch arms data:", armsData)
        return
    end

    if type(armsData) ~= "table" then
        warn("Invalid arms data received")
        return
    end

    -- Process arms data
    for armId, armInfo in pairs(armsData) do
        if type(armInfo) == "table" then
            local displayName = armInfo.ArmKey or "Unknown"
            
            if armInfo.Tier == "Normal" and not armInfo.Locked then
                if not SrvVars.Data.ownedArmsData[displayName] then
                    SrvVars.Data.ownedArmsData[displayName] = {}
                end
                
                table.insert(SrvVars.Data.ownedArmsData[displayName], {
                    Id = armId,
                    Locked = armInfo.Locked,
                    Mutation = armInfo.Mutation or "No Mutation"
                })
            end
        end
    end

    -- Sort and update unique arm names
    local armNameCounts = {}
    for armName, arms in pairs(SrvVars.Data.ownedArmsData) do
        table.insert(armNameCounts, {name = armName, count = #arms})
    end
    
    table.sort(armNameCounts, function(a, b) 
        return a.count > b.count 
    end)
    
    for _, armData in ipairs(armNameCounts) do
        table.insert(SrvVars.Data.uniqueArmNames, armData.name)
    end
end

-- Updated runAutoGoldPets function with error handling
local function runAutoGoldPets()
    spawn(function()
        while SrvVars.Data.autoGoldPets do
            if SrvVars.Data.selectedPetName and SrvVars.Data.selectedGoldChance then
                local petInstances = SrvVars.Data.ownedPetData[SrvVars.Data.selectedPetName] or {}
                local requiredCount = getRequiredCount(SrvVars.Data.selectedGoldChance)
                
                local selectedPetIds = getRandomIds(petInstances, requiredCount, SrvVars.Data.lastUsedPetIds, SrvVars.Data.selectedPetName)
                
                if #selectedPetIds >= requiredCount then
                    local args = { [1] = {} }
                    for i = 1, requiredCount do
                        args[1][i] = selectedPetIds[i]
                    end
                    
                    local success, result = pcall(function()
                        return game:GetService("ReplicatedStorage").Packages.Knit.Services.PetService.RF.goldify:InvokeServer(unpack(args))
                    end)
                    
                    if not success then
                        warn("Failed to goldify pets:", result)
                    end
                    
                    wait(0.7)
                    fetchOwnedPets()
                end
            end
            wait(1.25)
        end
    end)
end

-- Updated runAutoGoldArms function with error handling
local function runAutoGoldArms()
    spawn(function()
        while SrvVars.Data.autoGoldArms do
            if SrvVars.Data.selectedArms and SrvVars.Data.selectedArmChance then
                local armInstances = SrvVars.Data.ownedArmsData[SrvVars.Data.selectedArms] or {}
                local requiredCount = getRequiredCount(SrvVars.Data.selectedArmChance)
                
                local selectedArmIds = getRandomIds(armInstances, requiredCount, SrvVars.Data.lastUsedArmIds, SrvVars.Data.selectedArms)
                
                if #selectedArmIds >= requiredCount then
                    local args = { [1] = {} }
                    for i = 1, requiredCount do
                        args[1][i] = selectedArmIds[i]
                    end
                    
                    local success, result = pcall(function()
                        return game:GetService("ReplicatedStorage").Packages.Knit.Services.ArmsService.RF.EvolveArms:InvokeServer(unpack(args))
                    end)
                    
                    if not success then
                        warn("Failed to evolve arms:", result)
                    end
                    
                    wait(0.7)
                    fetchOwnedArms()
                end
            end
            wait(1.25)
        end
    end)
end

-- Create Sections
local GoldPetsSection = Tabs.Machines:AddSection("Gold Pets")
local GoldArmsSection = Tabs.Machines:AddSection("Gold Arms")

-- Pet Controls
local PetDropdown = GoldPetsSection:AddDropdown("PetDropdown", {
    Title = "Select Pet",
    Description = "Choose a specific unlocked pet name",
    Values = SrvVars.Data.uniquePetNames,
    Multi = false,
    Default = nil
})

PetDropdown:OnChanged(function(value)
    SrvVars.Data.selectedPetName = value
end)

local GoldChanceDropdown = GoldPetsSection:AddDropdown("GoldChanceDropdown", {
    Title = "Gold Chance",
    Description = "Select the gold chance for pets",
    Values = { "20%", "40%", "60%", "80%", "100%" },
    Multi = false,
    Default = "20%"
})

GoldChanceDropdown:OnChanged(function(value)
    SrvVars.Data.selectedGoldChance = value
end)

local AutoGoldPetsToggle = GoldPetsSection:AddToggle("AutoGoldPetsToggle", {
    Title = "Auto Gold Pets",
    Description = "Automatically gold pets",
    Default = false
})

AutoGoldPetsToggle:OnChanged(function(value)
    SrvVars.Data.autoGoldPets = value
    if value then
        runAutoGoldPets()
    end
end)

-- Arms Controls
local ArmsDropdown = GoldArmsSection:AddDropdown("ArmsDropdown", {
    Title = "Select Arms",
    Description = "Choose specific arms",
    Values = SrvVars.Data.uniqueArmNames,
    Multi = false,
    Default = nil
})

ArmsDropdown:OnChanged(function(value)
    SrvVars.Data.selectedArms = value
end)

local ArmChanceDropdown = GoldArmsSection:AddDropdown("ArmChanceDropdown", {
    Title = "Select Chance",
    Description = "Select the gold chance for arms",
    Values = { "20%", "40%", "60%", "80%", "100%" },
    Multi = false,
    Default = "20%"
})

ArmChanceDropdown:OnChanged(function(value)
    SrvVars.Data.selectedArmChance = value
end)

local AutoGoldArmsToggle = GoldArmsSection:AddToggle("AutoGoldArmsToggle", {
    Title = "Auto Gold Arms",
    Description = "Automatically gold arms",
    Default = false
})

AutoGoldArmsToggle:OnChanged(function(value)
    SrvVars.Data.autoGoldArms = value
    if value then
        runAutoGoldArms()
    end
end)

-- Function to refresh dropdowns
local function refreshDropdowns()
    fetchOwnedPets()
    PetDropdown:SetValues(SrvVars.Data.uniquePetNames)
    fetchOwnedArms()
    ArmsDropdown:SetValues(SrvVars.Data.uniqueArmNames)
end

GoldPetsSection:AddButton({
    Title = "Refresh/Get Pets",
    Description = "Manually refresh the gold pets dropdown",
    Callback = function()
        local success, error = pcall(function()
            fetchOwnedPets()
            PetDropdown:SetValues(SrvVars.Data.uniquePetNames)
        end)
        
        if success then
            print("Gold pets and arms refreshed successfully!")
        else
            warn("Failed to refresh gold pets/arms:", error)
        end
    end
})

GoldArmsSection:AddButton({
    Title = "Refresh/Get Arms",
    Description = "Manually refresh and arms for the gold arm dropdown",
    Callback = function()
        local success, error = pcall(function()
            fetchOwnedArms()
            ArmsDropdown:SetValues(SrvVars.Data.uniqueArmNames)
        end)
        
        if success then
            print("Gold pets and arms refreshed successfully!")
        else
            warn("Failed to refresh gold pets/arms:", error)
        end
    end
})


-- Services and data storage
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local PetServiceRF = ReplicatedStorage.Packages.Knit.Services.PetService.RF:FindFirstChild("getOwned")
local goldPetData = {}

-- Function to check instant void status
local function hasInstantVoid()
    return game.Players.LocalPlayer:GetAttribute("InstantVoid") == true
end

-- Function to fetch golden pets
local function fetchGoldPets()
    if not PetServiceRF then return {} end
    
    local success, petData = pcall(function()
        return PetServiceRF:InvokeServer()
    end)
    
    if not success or type(petData) ~= "table" then
        warn("Failed to fetch pet data")
        return {}
    end
    
    local pets = {}
    goldPetData = {}
    
    for petId, petInfo in pairs(petData) do
        if petInfo.Locked == false and petInfo.Tier == "Golden" then
            local name = petInfo.Key or "Unknown"
            if not goldPetData[name] then
                goldPetData[name] = {}
                table.insert(pets, name)
            end
            table.insert(goldPetData[name], petId)
        end
    end
    
    table.sort(pets)
    return pets
end

-- Function to void pet and claim reward
local function voidPetAndClaim(petId)
    -- Send to void
    local voidArgs = {[1] = petId}
    game:GetService("ReplicatedStorage").Packages.Knit.Services.PetVoidService.RE.onCraftToVoid:FireServer(unpack(voidArgs))
    
    -- Wait based on instant void status
    local waitTime = hasInstantVoid() and 4 or 18002
    wait(waitTime)
    
    -- Claim reward
    local claimArgs = {[1] = petId}
    game:GetService("ReplicatedStorage").Packages.Knit.Services.PetVoidService.RE.onClaim:FireServer(unpack(claimArgs))
end

-- Create UI section
local VoidSection = Tabs.Machines:AddSection("Void")

-- Create pet dropdown
local VoidPetDropdown = VoidSection:AddDropdown("VoidPetSelect", {
    Title = "Select Unlocked Golden Pet",
    Values = fetchGoldPets(),
    Multi = false,
    Default = nil,
    Callback = function(value)
        if goldPetData[value] then
            for _, id in ipairs(goldPetData[value]) do
            end
        end
    end
})

-- Create auto void toggle
local AutoVoidToggle = VoidSection:AddToggle("AutoVoid", {
    Title = "Auto Void",
    Default = false
})

-- Auto void loop with batch claiming
AutoVoidToggle:OnChanged(function(value)
    if value then
        spawn(function()
            while AutoVoidToggle.Value do
                if goldPetData[VoidPetDropdown.Value] then
                    local voidedPets = {}
                    
                    -- Void all pets first
                    for _, petId in ipairs(goldPetData[VoidPetDropdown.Value]) do
                        if not AutoVoidToggle.Value then break end
                        
                        -- Send to void
                        local voidArgs = {[1] = petId}
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.PetVoidService.RE.onCraftToVoid:FireServer(unpack(voidArgs))
                        table.insert(voidedPets, petId)
                        
                        wait(0.75) -- Wait between voids
                    end
                    
                    -- Wait 4 seconds or 18002 based on InstantVoid attribute
                    wait(hasInstantVoid() and 4 or 18002)
                    
                    -- Claim all voided pets
                    for _, petId in ipairs(voidedPets) do
                        if not AutoVoidToggle.Value then break end
                        
                        local claimArgs = {[1] = petId}
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.PetVoidService.RE.onClaim:FireServer(unpack(claimArgs))
                    end
                    
                    -- Clear voided pets array
                    table.clear(voidedPets)
                end
                wait(1)
            end
        end)
    end
end)

VoidSection:AddButton({
    Title = "Refresh/Get Gold Pets",
    Description = "Manually refresh and get pets for the void dropdown",
    Callback = function()
        local newPets = fetchGoldPets()
        VoidPetDropdown:SetValues(newPets)
        print("Void pets refreshed successfully!")
    end
})

local PristineSection = Tabs.Machines:AddSection("Pristine")

-- Services
local PristineRF = ReplicatedStorage.Packages.Knit.Services.PetService.RF:FindFirstChild("Pristine")

-- Variables
local voidPetData = {}  
local voidPetNames = {} 
local selectedPristinePet = nil
local selectedSuccessChance = "33%"
local isPristineRunning = false

-- Function to fetch void pets
local function fetchVoidPets()
    if not PetServiceRF then return {} end
    
    local success, petData = pcall(function()
        return PetServiceRF:InvokeServer()
    end)
    
    if not success or type(petData) ~= "table" then
        warn("Failed to fetch pet data")
        return {}
    end
    
    local pets = {}
    voidPetData = {}
    
    for petId, petInfo in pairs(petData) do
        -- Check if pet is Void tier and unlocked
        if petInfo.Locked == false and petInfo.Tier == "Void" then
            local name = petInfo.Key or "Unknown"
            if not voidPetData[name] then
                voidPetData[name] = {}
                table.insert(pets, name)
            end
            table.insert(voidPetData[name], petId)
        end
    end
    
    table.sort(pets)
    voidPetNames = pets
    return pets
end

-- Function to get required count based on success chance
local function getRequiredCount(chance)
    if chance == "33%" then
        return 2
    elseif chance == "66%" then
        return 2
    elseif chance == "100%" then
        return 3
    end
    return 2  -- Default to 66%
end

-- Create pet dropdown
local PristinePetDropdown = PristineSection:AddDropdown("PristinePetSelect", {
    Title = "Select Void Pet",
    Values = fetchVoidPets(),
    Multi = false,
    Default = nil
})

-- Create success chance dropdown
local SuccessChanceDropdown = PristineSection:AddDropdown("SuccessChance", {
    Title = "Select Success Chance",
    Values = {"33%", "66%", "100%"},
    Multi = false,
    Default = "33%"
})

-- Create auto pristine toggle
local AutoPristineToggle = PristineSection:AddToggle("AutoPristine", {
    Title = "Auto Pristine",
    Default = false
})

-- Dropdown callbacks
PristinePetDropdown:OnChanged(function(value)
    selectedPristinePet = value
    if voidPetData[value] then
    end
end)

SuccessChanceDropdown:OnChanged(function(value)
    selectedSuccessChance = value
end)

-- Auto pristine function
local function runAutoPristine()
    spawn(function()
        while isPristineRunning do
            if selectedPristinePet and voidPetData[selectedPristinePet] then
                local requiredCount = getRequiredCount(selectedSuccessChance)
                local availablePets = voidPetData[selectedPristinePet]
                
                -- Check if we have enough pets
                if #availablePets >= requiredCount then
                    local selectedPets = {}
                    
                    -- Select pets for pristine
                    for i = 1, requiredCount do
                        table.insert(selectedPets, availablePets[i])
                    end
                    
                    -- Send pristine request
                    local args = { [1] = selectedPets }
                    
                    pcall(function()
                        PristineRF:InvokeServer(unpack(args))
                    end)
                    
                    -- Wait a moment then refresh pet data
                    wait(1)
                    fetchVoidPets()
                else
                    wait(5)
                end
            else
                wait(1)
            end
        end
    end)
end

-- Toggle callback
AutoPristineToggle:OnChanged(function(value)
    isPristineRunning = value
    if value then
        if not selectedPristinePet then
            return
        end
        runAutoPristine()
    end
end)

-- Refresh button
PristineSection:AddButton({
    Title = "Refresh Void Pets",
    Description = "Manually refresh the void pet list for pristine",
    Callback = function()
        local pets = fetchVoidPets()
        PristinePetDropdown:SetValues(pets)
    end
})


-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ArmsServiceRF = ReplicatedStorage.Packages.Knit.Services.ArmsService.RF:FindFirstChild("getOwned")

-- Data Storage
local armsCache = {}

local function getForgeableArms()
    local success, data = pcall(function()
        return ArmsServiceRF:InvokeServer()
    end)
    
    if not success or type(data) ~= "table" then return {} end
    
    local organized = {}
    for id, info in pairs(data) do
        if not info.Locked then
            -- Extract strength tier number
            local strengthTier = tonumber(info.StrengthTier or "1")
            -- Skip if tier 5 or higher
            if strengthTier < 5 then
                local key = string.format("%s/%s/%s", 
                    info.ArmKey or "", 
                    info.Tier or "", 
                    tostring(strengthTier)
                )
                organized[key] = organized[key] or {}
                table.insert(organized[key], id)
            end
        end
    end
    return organized
end

-- Forge function
local function forgeArms(keyPath, ids)
    local args = {
        [1] = keyPath,
        [2] = ids
    }
    return game:GetService("ReplicatedStorage").Packages.Knit.Services.ForgeService.RF.Forge:InvokeServer(unpack(args))
end

-- Create UI
local ForgeSection = Tabs.Machines:AddSection("Auto Forge")

local AutoForgeToggle = Tabs.Machines:AddToggle("AutoForge", {
    Title = "Forge All Arms (Unlocked)",
    Default = false
})

-- Machines forge loop
AutoForgeToggle:OnChanged(function(value)
    if value then
        spawn(function()
            while AutoForgeToggle.Value do  -- Continuously check the toggle value
                -- Fetch the latest forgeable arms
                local arms = getForgeableArms()
                
                -- Sort keys by ArmKey and StrengthTier
                local sortedKeys = {}
                for key in pairs(arms) do
                    table.insert(sortedKeys, key)
                end
                table.sort(sortedKeys)
                
                -- Process each arm type in order
                for _, keyPath in ipairs(sortedKeys) do
                    if not AutoForgeToggle.Value then return end  -- Stop the loop immediately if toggle is off
                    local ids = arms[keyPath]
                    -- Extract current tier from keyPath
                    local strengthTier = tonumber(keyPath:match("[^/]+$"))
                    
                    while strengthTier < 5 and #ids >= 2 do
                        if not AutoForgeToggle.Value then return end  -- Stop the loop immediately if toggle is off
                        local forgeSet = {}
                        -- Get all available IDs for this forge
                        for i = 1, #ids do
                            table.insert(forgeSet, ids[i])
                        end
                        
                        if #forgeSet > 0 then
                            forgeArms(keyPath, forgeSet)
                            wait(0.75)
                        end
                        
                        -- Re-fetch the latest arms and ids for this keyPath
                        arms = getForgeableArms()
                        ids = arms[keyPath] or {}
                    end
                end
                
                wait(0.5)  -- Adjust wait time if necessary
            end
        end)
    end
end)


-- Load previously saved configurations
SaveManager:LoadAutoloadConfig()
